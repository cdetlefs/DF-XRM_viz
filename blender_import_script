
import bpy
import pickle
import math
from mathutils import Vector
import numpy as np
import bpy



'''
    needs imageio
    install in the blender python
    find by :
        import sys
        print(sys.exec_prefix)
    open a power shell and navigate there
    move to /bin/
    ensure pip is installed
        .\python.exe -m ensurepip
    install scipy
        .\python.exe -m pip install imageio

    if you do not have access, try:
        .\python.exe -m pip install imageio --user
    you will then need to note where it was installed, and copy it (and pillow) to
        C:\Program Files\Blender Foundation\Blender 2.91\2.91\python\lib\site-packages
    or equivalent

'''


def create_quadrilateral(nodes, name):
    # Define arrays for holding data
    myvertex = []
    myfaces = []

    # Create all Vertices
    # vertex 0
    mypoint = [tuple(nodes[0])]
    myvertex.extend(mypoint)

    # vertex 1
    mypoint = [tuple(nodes[1])]
    myvertex.extend(mypoint)

    # vertex 2
    mypoint = [tuple(nodes[3])]
    myvertex.extend(mypoint)

    # vertex 3
    mypoint = [tuple(nodes[2])]
    myvertex.extend(mypoint)

    # -------------------------------------
    # Create all Faces
    # -------------------------------------
    myface = [(0, 1, 3, 2)]
    myfaces.extend(myface)


    mymesh = bpy.data.meshes.new(name)
    myobject = bpy.data.objects.new(name, mymesh)
    bpy.context.collection.objects.link(myobject)

    # Generate mesh data
    mymesh.from_pydata(myvertex, [], myfaces)
    # Calculate the edges
    mymesh.update(calc_edges=True)

    # Set Location
    myobject.location.x = 0
    myobject.location.y = 0
    myobject.location.z = 0

    return myobject, mymesh

def make_line(nodes, name, r=0.1):
    d10 = nodes[1]-nodes[0]
    dist = np.sqrt(np.sum(d10**2))

    mesh = bpy.ops.mesh.primitive_cylinder_add(
        radius = r,
        depth = dist,
        location = np.average(nodes,axis=0)
        )

    phi = math.atan2(d10[1], d10[0])
    theta = math.acos(d10[2]/dist)
    myobject = bpy.context.object
    bpy.context.object.rotation_euler[1] = theta
    bpy.context.object.rotation_euler[2] = phi

    '''# Create all Vertices
    myvertex = []
    # vertex 0
    mypoint = [tuple(nodes[0])]
    myvertex.extend(mypoint)

    # vertex 1
    mypoint = [tuple(nodes[1])]
    myvertex.extend(mypoint)

    mymesh = bpy.data.meshes.new(name)
    myobject = bpy.data.objects.new(name, mymesh)
    bpy.context.collection.objects.link(myobject)

    mymesh.from_pydata(myvertex, [(0,1)], [])

    mymesh.update(calc_edges=True)

    # Set Location
    myobject.location.x = 0
    myobject.location.y = 0
    myobject.location.z = 0'''

    return myobject



def set_mat_keys(mat,color):
    nodes = mat.node_tree.nodes
    links = mat.node_tree.links
    node_output  = nodes.new(type='ShaderNodeOutputMaterial')
    node_output.location = 400,0
    node_pbsdf = nodes.new(type='ShaderNodeBsdfPrincipled')
    node_pbsdf.location = 0,0
    node_pbsdf.inputs['Base Color'].default_value = color
    node_pbsdf.inputs['Alpha'].default_value = color[-1] # 1 is opaque, 0 is invisible
    node_pbsdf.inputs['Roughness'].default_value = 0.2
    node_pbsdf.inputs['Specular'].default_value = 0.5
    node_pbsdf.inputs['Transmission'].default_value = 0.5 # 1 is fully transparent

    link = links.new(node_pbsdf.outputs['BSDF'], node_output.inputs['Surface'])
    mat.node_tree.nodes["Principled BSDF"].inputs['Base Color'].default_value = color
    mat.node_tree.nodes["Principled BSDF"].inputs['Alpha'].default_value = color[-1]
    mat.node_tree.nodes["Principled BSDF"].inputs['Roughness'].default_value = 0.2
    mat.node_tree.nodes["Principled BSDF"].inputs['Specular'].default_value = 0.5
    mat.node_tree.nodes["Principled BSDF"].inputs['Transmission'].default_value = 0.5
#curloc = bpy.context.scene.cursor.location

#create_custom_mesh("Awesome_object", curloc[0], curloc[1], 0)


for scene in bpy.data.scenes:
    for obj in scene.objects:
        print(obj.name)
        if not (obj.name == 'Light' or obj.name == 'Light.001' or obj.name =='Camera'):
            try:
                bpy.context.collection.objects.unlink(obj)
            except:
                None
path = "/home/trygvrad/DF-XRM_SimulationToolbox/IDEs.pickled"
objects = pickle.load( open( path, "rb" ) )

for i, object in enumerate(objects):
    # clean up old item
    objs = bpy.data.objects
    if str(i) in objs:
        objs.remove( objs[str(i)], do_unlink=True)
    mats = bpy.data.materials
    if str(i) in mats:
        mats.remove(mats[str(i)])

    if object['type']=='Mesh':

        mesh = bpy.data.meshes.new(str(i))   # create a new mesh
        for f in mesh.polygons:
                f.use_smooth = True
        ob = bpy.data.objects.new(str(i), mesh)      # create an object with that mesh
        ob.location = Vector((0,0,0)) #by.context.scene.cursor_location   # position object at 3d-cursor
        ob.active_material = mat
        bpy.context.collection.objects.link(ob)                # Link object to scene
        # st up material
        mat = bpy.data.materials.new(str(i))
        mat.diffuse_color = object['facecolor']
        mat.use_nodes=True
        nodes = mat.node_tree.nodes
        links = mat.node_tree.links
        ob.active_material = mat
        set_mat_keys(mat,object['facecolor'])


        #mat.node_tree.nodes["Transparent BSDF"].inputs[0].default_value = object['facecolor']

        # Fill the mesh with verts, edges, faces
        mesh.from_pydata(list(object['nodes']),[],list(object['faces']))   # edges or faces should be [], or you ask for problems
        mesh.update(calc_edges=True)    # Update mesh with new data

    elif object['type']=='BoxFacet':
        #for key in object:
        #    print(key)
        ob, mesh = create_quadrilateral(object['span'], str(i))
        mat = bpy.data.materials.new(str(i))
        mat.diffuse_color = object['facecolor']
        mat.use_nodes=True
        ob.active_material = mat
        set_mat_keys(mat,object['facecolor'])
    elif object['type']=='BoxLine':
        ob = make_line(object['span'], str(i), r=object['linewidth']*0.1)
        mat = bpy.data.materials.new(str(i))
        mat.diffuse_color = object['meshcolor']
        mat.use_nodes=True
        ob.active_material = mat
        set_mat_keys(mat,object['meshcolor'])
    elif object['type']=='QuadrilateralColormesh':
        for key in object:
            print(' ', key)
        ob, mesh = create_quadrilateral(object['span'][::-1], str(i))
        '''mat = bpy.data.materials.new(str(i))
        mat.diffuse_color = [0,0,0,1]
        mat.use_nodes=True
        ob.active_material = mat
        set_mat_keys(mat,[0,0,0,1])'''
        #from PIL import Image
        impath = path.split('.blend')[0]+'_'+str(i)+'.png'
        image = np.zeros((*object['image_data'].shape,4))
        import matplotlib.pyplot as plt
        if 1:
            object['image_data'] -= np.min(object['image_data'])
            object['image_data'] /= np.max(object['image_data'])
            image[:,:,:] = object['image_data'][:,:,np.newaxis]
            image[:,:,3] = 1
        if 0:
            cmap = plt.get_cmap('twilight')
            object['image_data'] -= np.min(object['image_data'])
            object['image_data'] /= np.max(object['image_data'])
            image[:,:,:] = cmap(object['image_data'])
            if not type(object['opacity_data']) == type(None):
                object['opacity_data'] -= np.min(object['opacity_data'])
                object['opacity_data'] /= np.max(object['opacity_data'])
            image[:,:,3] = object['opacity_data']
        import imageio
        imageio.imwrite(impath, np.swapaxes(image,0,1))

        mat = bpy.data.materials.new(name=str(i))
        mat.use_nodes = True
        mat.node_tree.nodes["Principled BSDF"].inputs['Specular'].default_value = 0
        nodes = mat.node_tree.nodes

        texImage = nodes.new('ShaderNodeTexImage')
        #impath = 'c:\\Users\\trygvrad\\Dropbox\\'+'IMG_20201204_171922.jpg'
        texImage.image = bpy.data.images.load(impath)
        ob.data.uv_layers.new(name="UvMap")
        #print(bpy.ops.mesh) #.uv_texture_add()


        principled = nodes['Principled BSDF']

        # What to link here?
        # mat.node_tree.links.new()
        mat.node_tree.links.new( texImage.outputs[0], principled.inputs[0] )
        ob.active_material = mat


    else:
        print(object['type'])
    #print(object['span'])
# spesific for this case
mats = bpy.data.materials
for i in range(6):
    mats[str(i)].node_tree.nodes["Principled BSDF"].inputs['Base Color'].default_value = [1,1,1,0.1]
    mats[str(i)].node_tree.nodes["Principled BSDF"].inputs['Alpha'].default_value = 0.03

#mats["42"].node_tree.nodes["Principled BSDF"].inputs['Roughness'].default_value = 1
#mats["43"].node_tree.nodes["Principled BSDF"].inputs['Roughness'].default_value = 1
#mats["44"].node_tree.nodes["Principled BSDF"].inputs['Roughness'].default_value = 1


if 0:
    mesh = bpy.data.meshes.new("penroseMesh")   # create a new mesh

    ob = bpy.data.objects.new("Penrose", mesh)      # create an object with that mesh
    ob.location = Vector((0,0,0)) #by.context.scene.cursor_location   # position object at 3d-cursor
    bpy.context.scene.objects.link(ob)                # Link object to scene

    # Fill the mesh with verts, edges, faces
    mesh.from_pydata(listVertices,[],listFaces)   # edges or faces should be [], or you ask for problems
    mesh.update(calc_edges=True)    # Update mesh with new data

# Set render resolution
scene.render.resolution_x = 1000
scene.render.resolution_y = 1000

# Set camera fov in degrees
import numpy as np
scene.camera.data.angle = 35*(np.pi/180.0)
scene.camera.rotation_euler[0] = 0*(np.pi/180.0)
scene.camera.rotation_euler[1] = 0*(np.pi/180.0)
scene.camera.rotation_euler[2] = 0*(np.pi/180.0)
scene.camera.location.x = 0
scene.camera.location.y = 0
scene.camera.location.z = 300
scene.camera.data.clip_end = 4000
bpy.data.worlds["World"].node_tree.nodes["Background"].inputs[0].default_value = (0.3, 0.3, 0.3, 1)
bpy.context.scene.render.engine = 'CYCLES'
#bpy.context.scene.render.film_transparent = True
bpy.context.scene.view_settings.view_transform = 'Standard'
